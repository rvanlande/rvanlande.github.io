{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nCes pages ont pour objectif de rassembler toutes les notes/codes/commandes de diff\u00e9rents outils informatiques.\n\n\nInstallation\n\n\n\n\nPr\u00e9-requis :\n\n\n\n\nInstaller mkdocs\n\n\n\n\nInstallation\n$ git clone github.com/rvanlande/rvanlande.github.io\n$ git checkout mkdocs\n\n\n\n\n\n\n\nMise \u00e0 jour de la documentation\n\n\n\n\n\n\nLa documentation se trouve dans le r\u00e9pertoire \nrvanlande.github.io/docs\n\n\n\n\n\n\nsauvegarde des mises \u00e0 jour dans git\n\n\n$ git commit -am 'update docs'\n$ git push origin mkdocs\n\n\n\n\n\n\n\nD\u00e9ploiement de la documentation\n\n\n$ mkdocs gh-deploy --remote-branch master", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Ces pages ont pour objectif de rassembler toutes les notes/codes/commandes de diff\u00e9rents outils informatiques.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "Pr\u00e9-requis :   Installer mkdocs   Installation $ git clone github.com/rvanlande/rvanlande.github.io\n$ git checkout mkdocs", 
            "title": "Installation"
        }, 
        {
            "location": "/#mise-a-jour-de-la-documentation", 
            "text": "La documentation se trouve dans le r\u00e9pertoire  rvanlande.github.io/docs    sauvegarde des mises \u00e0 jour dans git  $ git commit -am 'update docs'\n$ git push origin mkdocs", 
            "title": "Mise \u00e0 jour de la documentation"
        }, 
        {
            "location": "/#deploiement-de-la-documentation", 
            "text": "$ mkdocs gh-deploy --remote-branch master", 
            "title": "D\u00e9ploiement de la documentation"
        }, 
        {
            "location": "/docker/docker-compose/", 
            "text": "Docker Compose\n\n\nInstallation sur debian\n\n\nInstallation\n\n\nCommandes\n\n\nListe des commandes\n\n\n$ docker-compose up -d =\n construit, recr\u00e9e et attache les conteneurs au service\n$ docker-compose down =\n arr\u00eate les conteneurs et supprime les conteneurs, les r\u00e9seaux et les images cr\u00e9\u00e9es par up\n$ docker-compose start [service] =\n d\u00e9marre le ou les services\n$ docker-compose stop [service] =\n arr\u00eate le ou les services d\u00e9marr\u00e9s par start", 
            "title": "Docker compose"
        }, 
        {
            "location": "/docker/docker-compose/#docker-compose", 
            "text": "", 
            "title": "Docker Compose"
        }, 
        {
            "location": "/docker/docker-compose/#installation-sur-debian", 
            "text": "Installation", 
            "title": "Installation sur debian"
        }, 
        {
            "location": "/docker/docker-compose/#commandes", 
            "text": "Liste des commandes  $ docker-compose up -d =  construit, recr\u00e9e et attache les conteneurs au service\n$ docker-compose down =  arr\u00eate les conteneurs et supprime les conteneurs, les r\u00e9seaux et les images cr\u00e9\u00e9es par up\n$ docker-compose start [service] =  d\u00e9marre le ou les services\n$ docker-compose stop [service] =  arr\u00eate le ou les services d\u00e9marr\u00e9s par start", 
            "title": "Commandes"
        }, 
        {
            "location": "/docker/docker/", 
            "text": "Docker\n\n\nInstallation sur debian\n\n\nInstallation\n\n\nLe r\u00e9pertoire contenant tous les donn\u00e9es docker (image, conteneur,...) se trouve dans le r\u00e9pertoire suivant :  \n\n\n/var/lib/docker\n\n\n\nCommandes\n\n\nImage\n\n\n$ docker images    =\n Liste les images docker install\u00e9es\n$ docker rmi -f \nid_image\n    =\n force la suppression d'une image par son identifiant\n$ docker build -t \nnom_image\n:\ntag\n  \npath_dockerfile\n  =\n cr\u00e9e une image bas\u00e9e sur le Dockerfile avec un nom et un tag\n$ docker rmi $(docker images -q -f dangling=true) =\n supprime des images temporaires non utilis\u00e9es\n\n\n\nNOTES :\n\n\n\n\ndocker build : ex\u00e9cute toutes les commandes RUN du script dockerfile\n\n\ndocker run : ex\u00e9cute toutes les commandes CMD du script dockerfile\n\n\n\n\nConteneur\n\n\n$ docker ps -a    =\n liste tous les conteneurs\n$ docker ps -aq | xargs docker rm -v    =\n supprime tous les conteneurs et leur volume associ\u00e9\n\n\n\nVolume\n\n\nListe des volumes orphelins\n\n\n$ docker volume ls -qf dangling=true\n\n\n\nSuppression des volumes orphelins\n\n\n$ docker volume rm $(docker volume ls -qf dangling=true)\n\n\n\nImage vs Container\n\n\nUne image peut \u00eatre consid\u00e9r\u00e9 comme immuable. D\u00e9marrer un ou plusieurs conteneurs \u00e0 partir de cette image ne changera pas l'image. On peut comparer cela \u00e0 une image virtuelle originale d'une machine virtuelle.  \n\n\nUn conteneur d\u00e9marre l'image et ajoute une couche au-dessus de celle-ci. Cette couche stocke tous les changements du conteneur (cr\u00e9ation/modification/supression de fichiers ...).\n\n\nCr\u00e9ation d'une image\n\n\nCr\u00e9er un r\u00e9pertoire qui contiendra le fichier Dockerfile de cr\u00e9ation l'image\n\n\n$ mkdir -P createimage/ovya_go\n\n\n\nCr\u00e9er le fichier Dockerfile\n\n\n$ touch createimage/ovya_go/Dockerfile\n\n\n\nEditer le fichier et cr\u00e9er le script docker permettant de construire l'image, exemple cr\u00e9ation d'une image go\n\n\nFROM debian:latest\nMAINTAINER Renaud Vanlande \nrvanlande@ovya.fr\n\nRUN apt-get update \n apt-get install -y wget\nRUN wget https://storage.googleapis.com/golang/go1.6.2.linux-amd64.tar.gz \nRUN tar -C /usr/local -xzf go1.6.2.linux-amd64.tar.gz\nRUN rm -f go1.6.2.linux-amd64.tar.gz\nENV PATH=$PATH:/usr/local/go/bin\n\n\n\nCr\u00e9ation de l'image\n\n\n$ cd createimage/ovya_go\n$ docker build -t ovya/go:1.6.2 .\n\n\n\nCr\u00e9ation et ex\u00e9cution d'un conteneur\n\n\n$ docker run --rm --name ovya_clog --net=\"host\" -v /var/www/clog/:/var/www/clog ovya/clog\n\n\n\nCette commande cr\u00e9\u00e9e un contenur \novya_clog\n et le d\u00e9marre avec les options suivantes :  \n\n\n--rm\n supprime le conteneur \u00e0 la fin de son ex\u00e9cution  \n\n\n--name\n d\u00e9finit un nom pour le conteneur\n\n\n--net=\"host\"\n d\u00e9finit l'interface r\u00e9seau du conteneur avec celle de la machine h\u00f4te\n\n\n-v HOSTDIR:CONTAINERDIR\n partage d'un r\u00e9pertoire entre la machine h\u00f4te et le conteneur  \n\n\n$ docker run -it \nimage\n bin/bash\n\n\n\nCette commande cr\u00e9e et ex\u00e9cute un conteneur en ouvrant un terminal\n\n\n$ docker start \ncontainer_id\n\n\n\n\nD\u00e9marre un conteneur existant.\n\n\n$ docker exec -it \ncontainer_id\n bin/bash\n\n\n\nAttache un terminal \u00e0 un conteneur en cours d'ex\u00e9cution.\n\n\nExemple clog + pqsql clog\n\n\n\n\nContainer : ovya/clog\n\n\n\n\n\n\nconstruction de l'image ovya/clog\n\n\n\n\n~/dev/docker/createimage/ovya_clog/DockerFile \n\n\n$ se placer dans le r\u00e9pertoire\n$ docker build -t ovya/clog .\n\n\n\n\n\ncr\u00e9ation du conteneur\n\n\n\n\n$ docker create --name ovya_clog --net=\"host\" -v /var/www/clog/:/var/www/clog -v /var/log/nginx:/var/log/nginx ovya/clog\n\n\n\n\n\nlancement du conteneur\n\n\n\n\n$ docker start -a \nconteneur_id\n\n\n\n\n\n\nContainer : ovya/pgsql\n\n\n\n\n\n\nconstruction de l'image ovya/pgsql\n\n\n\n\n~/dev/docker/createimage/ovya_pgsql/\n\n\n\n\nDockerFile\n\n\n\n\ninit-db-user.sh : ex\u00e9cuter \u00e0 la cr\u00e9ation de l'image pour ajouter le user rcv\n\n\n$ se placer dans le r\u00e9pertoire\n$ docker build -t ovya/pgsql .\n\n\n\n\n\n\n\n\ncr\u00e9ation du conteneur\n\n\n\n\n$ docker create --name ovya-pgsql -e POSTGRES_PASSWORD=rcv -p 5432:5432 ovya/pgsql\n\n\n\n\n\nlancement du conteneur\n\n\n\n\n$ docker start -a \nconteneur_id\n\n\n\n\n\n\nEx\u00e9cution d'une migration (installation du sch\u00e9ma initial)\n\n\n\n\n$ se placer dans le r\u00e9pertoire /var/www/clog\n$ odbm up", 
            "title": "Docker"
        }, 
        {
            "location": "/docker/docker/#docker", 
            "text": "", 
            "title": "Docker"
        }, 
        {
            "location": "/docker/docker/#installation-sur-debian", 
            "text": "Installation  Le r\u00e9pertoire contenant tous les donn\u00e9es docker (image, conteneur,...) se trouve dans le r\u00e9pertoire suivant :    /var/lib/docker", 
            "title": "Installation sur debian"
        }, 
        {
            "location": "/docker/docker/#commandes", 
            "text": "", 
            "title": "Commandes"
        }, 
        {
            "location": "/docker/docker/#image", 
            "text": "$ docker images    =  Liste les images docker install\u00e9es\n$ docker rmi -f  id_image     =  force la suppression d'une image par son identifiant\n$ docker build -t  nom_image : tag    path_dockerfile   =  cr\u00e9e une image bas\u00e9e sur le Dockerfile avec un nom et un tag\n$ docker rmi $(docker images -q -f dangling=true) =  supprime des images temporaires non utilis\u00e9es  NOTES :   docker build : ex\u00e9cute toutes les commandes RUN du script dockerfile  docker run : ex\u00e9cute toutes les commandes CMD du script dockerfile", 
            "title": "Image"
        }, 
        {
            "location": "/docker/docker/#conteneur", 
            "text": "$ docker ps -a    =  liste tous les conteneurs\n$ docker ps -aq | xargs docker rm -v    =  supprime tous les conteneurs et leur volume associ\u00e9", 
            "title": "Conteneur"
        }, 
        {
            "location": "/docker/docker/#volume", 
            "text": "Liste des volumes orphelins  $ docker volume ls -qf dangling=true  Suppression des volumes orphelins  $ docker volume rm $(docker volume ls -qf dangling=true)", 
            "title": "Volume"
        }, 
        {
            "location": "/docker/docker/#image-vs-container", 
            "text": "Une image peut \u00eatre consid\u00e9r\u00e9 comme immuable. D\u00e9marrer un ou plusieurs conteneurs \u00e0 partir de cette image ne changera pas l'image. On peut comparer cela \u00e0 une image virtuelle originale d'une machine virtuelle.    Un conteneur d\u00e9marre l'image et ajoute une couche au-dessus de celle-ci. Cette couche stocke tous les changements du conteneur (cr\u00e9ation/modification/supression de fichiers ...).", 
            "title": "Image vs Container"
        }, 
        {
            "location": "/docker/docker/#creation-dune-image", 
            "text": "Cr\u00e9er un r\u00e9pertoire qui contiendra le fichier Dockerfile de cr\u00e9ation l'image  $ mkdir -P createimage/ovya_go  Cr\u00e9er le fichier Dockerfile  $ touch createimage/ovya_go/Dockerfile  Editer le fichier et cr\u00e9er le script docker permettant de construire l'image, exemple cr\u00e9ation d'une image go  FROM debian:latest\nMAINTAINER Renaud Vanlande  rvanlande@ovya.fr \nRUN apt-get update   apt-get install -y wget\nRUN wget https://storage.googleapis.com/golang/go1.6.2.linux-amd64.tar.gz \nRUN tar -C /usr/local -xzf go1.6.2.linux-amd64.tar.gz\nRUN rm -f go1.6.2.linux-amd64.tar.gz\nENV PATH=$PATH:/usr/local/go/bin  Cr\u00e9ation de l'image  $ cd createimage/ovya_go\n$ docker build -t ovya/go:1.6.2 .", 
            "title": "Cr\u00e9ation d'une image"
        }, 
        {
            "location": "/docker/docker/#creation-et-execution-dun-conteneur", 
            "text": "$ docker run --rm --name ovya_clog --net=\"host\" -v /var/www/clog/:/var/www/clog ovya/clog  Cette commande cr\u00e9\u00e9e un contenur  ovya_clog  et le d\u00e9marre avec les options suivantes :    --rm  supprime le conteneur \u00e0 la fin de son ex\u00e9cution    --name  d\u00e9finit un nom pour le conteneur  --net=\"host\"  d\u00e9finit l'interface r\u00e9seau du conteneur avec celle de la machine h\u00f4te  -v HOSTDIR:CONTAINERDIR  partage d'un r\u00e9pertoire entre la machine h\u00f4te et le conteneur    $ docker run -it  image  bin/bash  Cette commande cr\u00e9e et ex\u00e9cute un conteneur en ouvrant un terminal  $ docker start  container_id   D\u00e9marre un conteneur existant.  $ docker exec -it  container_id  bin/bash  Attache un terminal \u00e0 un conteneur en cours d'ex\u00e9cution.", 
            "title": "Cr\u00e9ation et ex\u00e9cution d'un conteneur"
        }, 
        {
            "location": "/docker/docker/#exemple-clog-pqsql-clog", 
            "text": "Container : ovya/clog    construction de l'image ovya/clog   ~/dev/docker/createimage/ovya_clog/DockerFile   $ se placer dans le r\u00e9pertoire\n$ docker build -t ovya/clog .   cr\u00e9ation du conteneur   $ docker create --name ovya_clog --net=\"host\" -v /var/www/clog/:/var/www/clog -v /var/log/nginx:/var/log/nginx ovya/clog   lancement du conteneur   $ docker start -a  conteneur_id    Container : ovya/pgsql    construction de l'image ovya/pgsql   ~/dev/docker/createimage/ovya_pgsql/   DockerFile   init-db-user.sh : ex\u00e9cuter \u00e0 la cr\u00e9ation de l'image pour ajouter le user rcv  $ se placer dans le r\u00e9pertoire\n$ docker build -t ovya/pgsql .     cr\u00e9ation du conteneur   $ docker create --name ovya-pgsql -e POSTGRES_PASSWORD=rcv -p 5432:5432 ovya/pgsql   lancement du conteneur   $ docker start -a  conteneur_id    Ex\u00e9cution d'une migration (installation du sch\u00e9ma initial)   $ se placer dans le r\u00e9pertoire /var/www/clog\n$ odbm up", 
            "title": "Exemple clog + pqsql clog"
        }, 
        {
            "location": "/git/git/", 
            "text": "Annuler un merge/commit local\n\n\n$ git reflog =\n montre les r\u00e9f\u00e9rences HEAD\n$ git reset --hard HEAD@{X} =\n repositionne le head de la branche sur le commit correspondant  \n/!\\ Attention la commande annule toutes les modifications en cours de la branches stagged + commited\n\n\n\n\n\n\n\nRecherche des commit li\u00e9s au texte\n\n\n[alias] :\nstr-search = \"!f() { git llg -S $1 --all --source $2; }; f\"", 
            "title": "Git"
        }, 
        {
            "location": "/linux/linux/", 
            "text": "voir les ports ouverts :\n$ sudo netstat -tulpn", 
            "title": "Linux"
        }, 
        {
            "location": "/sql/sql/", 
            "text": "PostgreSql\n\n\n\n\n\n\nconnect to database\n\n\npsql -U rcv ${db_name}\n\n\n\n\n\n\n\ndsiplay result in page mode\n\n\n\\pset pager on\n\n\n\n\n\n\n\nchange database\n\n\n\\c \nother_db\n\n\n\n\n\n\n\n\nsave database\n\n\npg_dump -Fc ${db_name} \n ${dump_name}.dmp\n\n\n\n\n\n\n\nrestore database\n\n\npg_restore -d ${db_name} ${dump_name}.dmp\n\n\n\n\n\n\n\ndrop database\n\n\ndropdb -U rcv 'costespro4timeline'\n\n\n\n\n\n\n\nduplicate database\n\n\n$ su -\n$ su - postgres   // connect as postgre user\n$ psql            // conect to database\n~=\n CREATE DATABASE costespro4timeline WITH TEMPLATE costespro OWNER rcv;\n\n\n\n\n\n\n\nsessions connected to database\n\n\nselect * from pg_stat_activity;\n\n\n\n\n\n\n\nget information about database\n\n\nselect table_name, column_name\nfrom information_schema.columns\nwhere column_name like '%depose%' order by table_name, column_name;\n\n\n\n\n\n\n\ndisplay enumeration type\n\n\nselect n.nspname as enum_schema, t.typname as enum_name, e.enumlabel as enum_value \nfrom pg_type t join pg_enum e\non t.oid = e.enumtypid join pg_catalog.pg_namespace n\non n.oid = t.typnamespace \nwhere t.typname = 'email_params_type';", 
            "title": "Sql"
        }, 
        {
            "location": "/sql/sql/#postgresql", 
            "text": "connect to database  psql -U rcv ${db_name}    dsiplay result in page mode  \\pset pager on    change database  \\c  other_db     save database  pg_dump -Fc ${db_name}   ${dump_name}.dmp    restore database  pg_restore -d ${db_name} ${dump_name}.dmp    drop database  dropdb -U rcv 'costespro4timeline'    duplicate database  $ su -\n$ su - postgres   // connect as postgre user\n$ psql            // conect to database\n~=  CREATE DATABASE costespro4timeline WITH TEMPLATE costespro OWNER rcv;    sessions connected to database  select * from pg_stat_activity;    get information about database  select table_name, column_name\nfrom information_schema.columns\nwhere column_name like '%depose%' order by table_name, column_name;    display enumeration type  select n.nspname as enum_schema, t.typname as enum_name, e.enumlabel as enum_value \nfrom pg_type t join pg_enum e\non t.oid = e.enumtypid join pg_catalog.pg_namespace n\non n.oid = t.typnamespace \nwhere t.typname = 'email_params_type';", 
            "title": "PostgreSql"
        }
    ]
}